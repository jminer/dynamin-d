// Written in the D programming language
// www.digitalmars.com/d/

/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Dynamin library.
 *
 * The Initial Developer of the Original Code is Jordan Miner.
 * Portions created by the Initial Developer are Copyright (C) 2006-2009
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Jordan Miner <jminer7@gmail.com>
 *
 */

module dynamin.gui.events;

import dynamin.all_core;
import dynamin.all_painting;
import dynamin.all_gui;

///
enum MouseButton {
	None,     ///
	Left,     ///
	Right,    ///
	Middle,   ///
	XButton1, ///
	XButton2  ///
}

///
class PaintingEventArgs : EventArgs {
	Graphics g;
	//NativeGraphics ng;
public:
	///
	this(Graphics g) {
		this.g = g;
	}
	///
	Graphics graphics() { return g; }
}

///
class MouseEventArgs : StopEventArgs {
	Point _location;
	MouseButton _button;
public:
	///
	this(real x, real y, MouseButton b) {
		_location = Point(x, y);
		_button = b;
	}
	///
	Point location() { return _location; }
	///
	void location(Point pt) { _location = pt; }
	///
	real x() { return _location.x; }
	///
	real y() { return _location.y; }
	///
	MouseButton button() { return _button; }
	string toString() {
		return format("MouseEventArgs [x={}, y={}, button={}]",
			x, y, _button);
	}
}
///
class MouseTurnedEventArgs : StopEventArgs {
	double _scrollAmount;
public:
	this(double scrollAmount) {
		_scrollAmount = scrollAmount;
	}
	/**
	 * The amount that a control should scroll in response to this event.
	 * In a text control, this is the number of lines to scroll.
	 * This will be negative if the control should scroll upward and positive
	 * if the control should scroll downward. If the amount to be scrolled
	 * is more than what is visible on screen, only what is on screen
	 * should be scrolled.
	 *
	 * All users of this class should check scrollScreen to see whether to
	 * scroll one screen or to scroll the amount by this.
	 */
	double scrollAmount() { return _scrollAmount; }
	/**
	 * On some systems, such as Windows, there is the option of setting
	 * the mouse wheel to scroll a screen at a time, the same as the page up
	 * and page down keys do. If this option is turned on, scrollScreen will
	 * return true and scrollAmount will return Â±3. If the option is turned off,
	 * scrollScreen will return false.
	 */
	bool scrollScreen() {
		return false;
	}
	string toString() {
		return format("MouseTurnedEventArgs [scrollAmount={}, scrollScreen={}]",
			_scrollAmount, scrollScreen);
	}
}
///
class KeyEventArgs : StopEventArgs {
	Key _key;
	bool _repeat;
public:
	this(Key key, bool repeat) {
		_key = key;
		_repeat = repeat;
	}
	/**
	 * Returns: the key that was typed.
	 */
	Key key() { return _key; }
	/**
	 * Gets whether this key event was generated by the user holding
	 * down the key.
	 * Returns: true if the key was already down before this event, false
	 *          if the key was just pressed
	 */
	bool repeat() { return _repeat; }
	string toString() {
		return format("KeyEventArgs [key={}, repeat={}]", _key, _repeat);
	}
}
///
class KeyTypedEventArgs : StopEventArgs {
	dchar _ch;
	bool _repeat;
public:
	this(dchar c, bool repeat) {
		_ch = c;
		_repeat = repeat;
	}
	/**
	 * Gets whether this key event was generated from the user holding
	 * down the key.
	 * Returns: true if the key was already down before this event, false
	 *          if the key was just pressed
	 */
	bool repeat() { return _repeat; }
	/**
	 * Gets the character that was typed by the user. Many keys on the
	 * keyboard will not generate a KeyTyped event, as they do not represent
	 * characters. Shift, Insert, Home, F7, and Caps Lock are just some of
	 * the keys that do not represent characters.
	 */
	dchar character() { return _ch; }
}

